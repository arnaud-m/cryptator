#+SETUPFILE: ~/.emacs.d/org-templates/base.org
#+TITLE: Notes about the experimental protocol
#+DESCRIPTION:
#+KEYWORDS:
#+TEXT:
#+OPTIONS: H:2 num:nil toc:2
#+LANGUAGE: en
#+PROPERTY: header-args :results silent :exports code :session cryptarithm
#+HTML_HEAD:    <link rel="stylesheet" type="text/css" href="http://www.i3s.unice.fr/~malapert/css/worg.min.css" />
* Initialize and Configure
** Create Symlinks

#+BEGIN_SRC sh :results silent
   ln -s ../words .
   ln -s ../../../target/cryptator-0.6.0-SNAPSHOT-with-dependencies.jar .
 #+END_SRC

** Clear directories

 #+BEGIN_SRC sh
   rm -fr instances
   mkdir instances/
 #+END_SRC

 #+BEGIN_SRC sh
   rm -fr algorithms
   mkdir algorithms/
 #+END_SRC

** Generation functions

 #+BEGIN_SRC sh
   function generateWordList() {
       find words/ -type f -name '*.txt' -exec wc -w {} \; | while read WORDCOUNT PATHNAME ; do
           if [ $WORDCOUNT -ge $1 ] && [ $WORDCOUNT -le $2 ] ; then
               INSTANCE="instances/"`basename -s .txt $PATHNAME`.dat
               echo $PATHNAME > $INSTANCE
            fi
        done
   }

    function generateDoublyTrue() {
       LANGUAGES=../shell/language-codes.csv
       # Read the csf files with a list of country codes, and languages codes
       while IFS="," read ctry lang ; do
           INSTANCE="instances/$lang-$1-$2.dat"
           echo -ctry $ctry -lang $lang $1 $2 > $INSTANCE
       done < <(grep -v "^#\|^$" $LANGUAGES)
   }
 #+END_SRC


* Generate

** Create the solver

#+BEGIN_SRC sh :tangle solver.sh
JAR=cryptator-0.6.0-SNAPSHOT-with-dependencies.jar
MAINCLASS=cryptator.Cryptagen

MAINARGS=`cat $1 $2 | xargs`

INSTNAME=`echo $INSTNAME | sed 's/\s-*/-/g'`
echo i `basename -s .dat $2`
## SEED=`shuf -i1-1000 -n1`
java -server  -Xms512m -Xmx8192m -cp $JAR $MAINCLASS $MAINARGS
exit $?
 #+END_SRC

** Configure instances

#+BEGIN_SRC sh
  generateWordList 1 70
  generateDoublyTrue 1 200
 #+END_SRC

** Configure algorithms

*** Best algorithm
 #+BEGIN_SRC sh
   echo -v normal -d TRUE -lightM FALSE -lightP FALSE > algorithms/FF.dat
 #+END_SRC

*** All algorithms

 #+BEGIN_SRC sh
   echo -v normal -d TRUE -lightM FALSE -lightP FALSE > algorithms/FF.dat
   echo -v normal -d TRUE -lightM FALSE -lightP TRUE > algorithms/FT.dat
   echo -v normal -d TRUE -lightM TRUE -lightP FALSE > algorithms/TF.dat
   echo -v normal -d TRUE -lightM TRUE -lightP TRUE > algorithms/TT.dat
 #+END_SRC




* Generate and Solve
** Create the solver

#+BEGIN_SRC sh :tangle solver.sh
JAR=cryptator-0.6.0-SNAPSHOT-with-dependencies.jar
MAINCLASS=cryptator.Cryptagen

MAINARGS=`cat $1 $2 | xargs`

java -server  -Xms512m -Xmx8192m -cp $JAR $MAINCLASS $MAINARGS | head -n -10
exit $?
 #+END_SRC

** Configure instances

*** Enumerate Doubly True

#+BEGIN_SRC sh
  generateDoublyTrue 401 500
 #+END_SRC


Interrupted processes
  - pt-301-400
  - el-301-400
  - ro-301-400
  - el-401-500

*** Enumerate all cryptarithms

The word lists ~colors.txt~ and ~monsters.txt~ takes the most time by far (around 110K candidates).

#+BEGIN_SRC sh
  for FILENAME in sports.txt virtues.txt astro.txt alpha.txt europeans.txt vegetables.txt games.txt fruits.txt cryptarithm.txt instruments.txt happy.txt rainbow.txt planets.txt mythologie-grecque/cyclopes.txt mythologie-grecque/divinites-olympiennes.txt mythologie-grecque/divinites-primordiales.txt mythologie-grecque/geants.txt mythologie-grecque/demi-dieux.txt mythologie-grecque/titans.txt asterix/asterix.txt colors.txt monsters.txt; do
      PATHNAME="words/$FILENAME"
      INSTANCE="instances/"`basename -s .txt $FILENAME`.dat
      echo $PATHNAME > $INSTANCE
  done
 #+END_SRC


*** Enumerate the longest cryptarithms

  I have found manually the longest cryptarithms of the remaining word lists.

 #+BEGIN_SRC sh
   function generateLong() {
       echo -minop $1 -maxop $1 words/$2 > instances/`basename -s .txt $2`-$1.dat
   }

   # generateLong 9 9 monsters.txt
   # generateLong 9 9 colors.txt
   generateLong 14 elements.txt
   generateLong 49 palindromes-fr.txt
   generateLong 41 palindromes-en.txt
   generateLong 15 capitales.txt
   generateLong 16 capitales.txt
 #+END_SRC



*** Enumerate samples

 #+BEGIN_SRC sh
   rm -fr samples
   mkdir samples
   (
       cd samples
       pwd
       ../../R/sample-words.R -n 2 -w 25 --minlen 12 --maxlen 16  ../../words/liste.de.mots.francais.frgut.txt
   )
 #+END_SRC

 #+BEGIN_SRC sh
   function generateMaxLong() {
       find samples/ -type f -print | while read PATHNAME ; do
           INSTANCE="instances/"`basename -s .txt $PATHNAME`-$1-$2.dat
           echo -minop $1 -maxop $2 $PATHNAME > $INSTANCE
        done
   }

   min=4
   step=2
   max=17
   while [ $min -lt $max ] ; do
       generateMaxLong $min $((min+step-1))
       min=$((min+step))
   done


 #+END_SRC

*** Generate languages

 #+BEGIN_SRC R :results output file :file "words-10-2.txt"
   base <- 10
   x <- head(letters, base)
   xy <- expand.grid(x = head(x, 2), y = x)
   cat(paste(x, '\n', collapse = ''))
   cat(paste(xy$x, xy$y, '\n', sep = "", collapse = ''))
#+END_SRC

 #+BEGIN_SRC R :results output file :file "words-10-2.txt"
   base <- 10
   x <- head(letters, base)
   xy <-  expand.grid(x = x,  y = x)
   xyz <- expand.grid(x = head(x, 1), y = tail(x, 2), z = x)
   cat(paste(x, '\n', collapse = ''))
   cat(paste(xy$x, xy$y, '\n', sep = "", collapse = ''))
   cat(paste(xyz$x, xyz$y, xyz$z,'\n', sep = "", collapse = ''))
#+END_SRC


** Configure the algorithm

 #+BEGIN_SRC sh
   echo -v quiet -d FALSE -l TRUE -lightM FALSE -lightP FALSE > algorithms/ALL.dat
 #+END_SRC


* Solve
** Create the solver

#+BEGIN_SRC sh :tangle solver.sh
  JAR=cryptator-0.6.0-SNAPSHOT-with-dependencies.jar
  MAINCLASS=cryptator.Cryptator

  MAINARGS=`cat $1 | xargs`

  ## exclude cryptarithm with long words
  ## grep -wvE '\w{10,}' $2 | sed 's/[[:space:]]//g'  | xargs java -server  -Xms512m -Xmx8192m -cp $JAR $MAINCLASS $MAINARGS

  ## exclude cryptarithm without long words
  ## grep -wE '\w{10,}' $2 | sed 's/[[:space:]]//g'  | xargs java -server  -Xms512m -Xmx8192m -cp $JAR $MAINCLASS $MAINARGS

  ## Do not exclude anything
  sed 's/[[:space:]]//g'  $2 | xargs java -server  -Xms512m -Xmx8192m -cp $JAR $MAINCLASS $MAINARGS
  exit $?
 #+END_SRC

** Configure instances

Select instance files in the directory ~instances-solve~.

 - Filename prefixed by ~long~ requires the bignum model.
 - Filename prefixed by ~short~ are accepted by the scalar model.

** Configure the algorithm

 #+BEGIN_SRC sh
   ARGS=" -v verbose -t 10"
   echo $ARGS -l TRUE > algorithms/BIGNUM.dat
   echo $ARGS -l FALSE -h FALSE > algorithms/SCALAR.dat
   echo $ARGS -l FALSE -h TRUE > algorithms/HORNER.dat

   echo $ARGS -l TRUE -search 1 > algorithms/BIGNUM-1.dat
   echo $ARGS -l FALSE -h FALSE -search 1 > algorithms/SCALAR-1.dat
   echo $ARGS -l FALSE -h TRUE -search 1 > algorithms/HORNER-1.dat
 #+END_SRC


* Testing

Change the file extension accordingly.

** Solve instances in sequential
   #+BEGIN_SRC sh
     nohup gridjobs  -l -p '*.dat' &
   #+END_SRC

** Solve instances in parallel.
   #+BEGIN_SRC sh
     gridjobs  -d 0 -p '*.dat' | nohup parallel -j 20 &
   #+END_SRC

* Reporting

#+BEGIN_SRC sh
  gridres -z -k table-keys.txt
#+END_SRC

  Look for the files .res in the results directory.

** Create cryptarithm database

#+BEGIN_SRC sh
  OUTDIR=results-cryptarithms
  rm -fr $OUTDIR
  mkdir $OUTDIR
  ## Extract cryptarithms
  SED_EXPR="N;  s/^[^\n]*Find .*\[OK\]\n//p ; D"
  find results -name '*.o' | while read INFILE ; do
      OUTFILE=$OUTDIR/`basename -s .o $INFILE`.db.txt
       sed -n "$SED_EXPR" $INFILE >> $OUTFILE
    done
  ## Sort cryptarithms
  find $OUTDIR -name '*.db.txt' -exec sort -u -o {} {} \;

#+END_SRC

** Classify cryptarithms


#+BEGIN_SRC awk :tangle classify-additions.awk
  {
   operands = int(NF/2)
   minlen = length($1)
   maxlen = length($1)
   for(i = 3 ; i < NF ; i+=2) {
       if(length($i) < minlen) minlen=length($i);
       else if(length($i) > maxlen) maxlen=length($i);
   }
   filename=sprintf("N%02d-%02d-%02d.db.txt", operands, minlen, maxlen)
   #print operands, minlen, maxlen, filename, $0
   print $0 >> filename;
  }

#+END_SRC


#+BEGIN_SRC sh
  INDIR=results-cryptarithms
  OUTDIR=results-classified
#  rm -fr $OUTDIR
#  mkdir $OUTDIR
  ## Classify
  (
      cd $OUTDIR
      find ../$INDIR -name "*.db.txt" -exec awk -f ../classify-additions.awk {} \;

  )
  ## Sort cryptarithms
  find $OUTDIR -name '*.db.txt' -exec sort -u -o {} {} \;

#+END_SRC



#+BEGIN_SRC sh
  OUTDIR=results-classified
  TEMPFILE=`mktemp`
  wc -l $OUTDIR/* | head -n -1 | while read LINECOUNT DBFILE ; do
      if [ $LINECOUNT -gt 1000 ] ; then
      head -n 1000 $DBFILE > $TEMPFILE
      mv $TEMPFILE $DBFILE
      fi
    done

#+END_SRC



* Analysis

#+BEGIN_SRC R

  dbfiles <- list.files(c("../cryptarithms", "results-classified"), full.names=TRUE)
  cryptarithms <- unlist(sapply(dbfiles, readLines))
  cryptarithms <- subset(cryptarithms, nchar(cryptarithms) > 0)
  operands <- strsplit(cryptarithms, "[ +=]+")

  ExtractFeatures <- function(x) {
    y <- nchar(x)
    r <- range(y)
    c( words = length(x), meanLen = mean(y), medianLen = median(y), minLen = r[1], maxLen = r[2])
  }

  features <- as.data.frame(t(sapply(operands, ExtractFeatures)))
  cat(nrow(features), "cryptarithms in database\n")
  summary(features)

  library(dplyr)
  library(ggplot2)
  x <- features %>% count(words, maxLen)
  x$n <- log10(x$n)
  ggplot(x, aes(words, maxLen, fill= n)) +
  geom_tile()

#+END_SRC
